name: Auto Merge Pull Requests
on:
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch:
  pull_request:
    types: [opened, synchronize, ready_for_review]

jobs:
  auto_merge:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: write
      checks: read
      statuses: read
      actions: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ github.token }}

      - name: Set up Git
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Intelligent Auto-merge with Self-Reference Detection
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_TOKEN: ${{ github.token }}
        uses: actions/github-script@v7
        with:
          script: |
            const currentWorkflow = context.workflow;
            console.log(`ğŸ”§ Current workflow: ${currentWorkflow}`);
            
            // Get all open PRs
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            
            if (prs.length === 0) {
              console.log('â„¹ï¸ No open pull requests found.');
              return;
            }
            
            console.log(`ğŸ“‹ Found ${prs.length} open PR(s)`);
            
            for (const pr of prs) {
              console.log('================================================');
              console.log(`ğŸ”„ Processing PR #${pr.number}: ${pr.title}`);
              console.log(`ğŸ‘¤ Author: ${pr.user.login}`);
              console.log(`ğŸŒ¿ Branch: ${pr.head.ref} â†’ ${pr.base.ref}`);
              console.log(`ğŸ”— URL: ${pr.html_url}`);
              
              // Enhanced PR analysis
              console.log('ğŸ” Analyzing PR eligibility...');
              
              // Check if this is an automated PR
              const isAutomatedPR = pr.user.login.includes('bot') || 
                                   pr.user.login === 'xuqssq' ||
                                   pr.title.includes('ğŸ¤–') ||
                                   pr.title.includes('Automated') ||
                                   pr.title.includes('auto-update') ||
                                   pr.head.ref.includes('auto-update');
              
              console.log(`ğŸ¤– Automated PR: ${isAutomatedPR}`);
              
              // Get detailed PR status
              const { data: prDetails } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              console.log(`ğŸ“Š Basic Status:`);
              console.log(`   â€¢ Mergeable: ${prDetails.mergeable}`);
              console.log(`   â€¢ Review decision: ${prDetails.mergeable_state}`);
              
              // Check status checks with intelligent filtering
              const { data: statusChecks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              console.log('ğŸ§ª Analyzing status checks...');
              
              // Define checks to ignore for automated PRs
              const ignoredChecksForAuto = [
                currentWorkflow,
                'auto_merge',
                'Auto Merge Pull Requests',
                'auto-merge',
                'merge-pr'
              ];
              
              const allChecks = statusChecks.check_runs;
              const relevantChecks = allChecks.filter(check => {
                if (isAutomatedPR) {
                  // For automated PRs, ignore self-referencing checks
                  return !ignoredChecksForAuto.some(ignored => 
                    check.name.toLowerCase().includes(ignored.toLowerCase()) ||
                    ignored.toLowerCase().includes(check.name.toLowerCase())
                  );
                } else {
                  // For manual PRs, include all checks
                  return true;
                }
              });
              
              console.log(`   ğŸ“ Total checks found: ${allChecks.length}`);
              console.log(`   ğŸ¯ Relevant checks: ${relevantChecks.length}`);
              
              if (allChecks.length > 0) {
                console.log('   ğŸ“‹ All checks:');
                allChecks.forEach(check => {
                  const isIgnored = isAutomatedPR && ignoredChecksForAuto.some(ignored => 
                    check.name.toLowerCase().includes(ignored.toLowerCase())
                  );
                  console.log(`   - ${check.name}: ${check.conclusion || check.status} ${isIgnored ? '(ignored)' : ''}`);
                });
              }
              
              // Analyze relevant check results
              const failedRelevantChecks = relevantChecks.filter(
                check => ['failure', 'error', 'cancelled'].includes(check.conclusion)
              );
              
              const pendingRelevantChecks = relevantChecks.filter(
                check => ['pending', 'in_progress', 'queued'].includes(check.status) && !check.conclusion
              );
              
              const allRelevantChecksPassed = failedRelevantChecks.length === 0 && pendingRelevantChecks.length === 0;
              
              console.log(`   âœ… Relevant checks passed: ${allRelevantChecksPassed}`);
              
              if (failedRelevantChecks.length > 0) {
                console.log('   âŒ Failed relevant checks:');
                failedRelevantChecks.forEach(check => {
                  console.log(`      - ${check.name}: ${check.conclusion}`);
                });
              }
              
              if (pendingRelevantChecks.length > 0) {
                console.log('   â³ Pending relevant checks:');
                pendingRelevantChecks.forEach(check => {
                  console.log(`      - ${check.name}: ${check.status}`);
                });
              }
              
              // Enhanced merge decision logic
              let canMerge = false;
              let mergeReason = '';
              
              // Check basic requirements
              const isMergeable = prDetails.mergeable === true || 
                                 (prDetails.mergeable === null && prDetails.mergeable_state !== 'dirty');
              
              const reviewApproved = !prDetails.draft && 
                                   (prDetails.mergeable_state === 'clean' || 
                                    prDetails.mergeable_state === 'unstable' ||
                                    (isAutomatedPR && prDetails.mergeable_state !== 'dirty'));
              
              console.log(`ğŸ“Š Merge eligibility analysis:`);
              console.log(`   â€¢ Is mergeable: ${isMergeable}`);
              console.log(`   â€¢ Review approved: ${reviewApproved}`);
              console.log(`   â€¢ All relevant checks passed: ${allRelevantChecksPassed}`);
              
              if (isMergeable && reviewApproved && allRelevantChecksPassed) {
                canMerge = true;
                mergeReason = isAutomatedPR ? 
                  'Automated PR with passing critical checks (self-checks ignored)' :
                  'All checks passed and ready to merge';
              } else if (isAutomatedPR && isMergeable && failedRelevantChecks.length === 0) {
                // Special handling for automated PRs with only self-check failures
                const onlySelfChecksFailed = allChecks.length > 0 && relevantChecks.length === 0;
                if (onlySelfChecksFailed) {
                  console.log('   ğŸ’¡ Only self-referencing checks are failing');
                  canMerge = true;
                  mergeReason = 'Automated PR - self-check failures bypassed';
                }
              }
              
              console.log(`ğŸ¯ Final Decision: ${canMerge ? 'MERGE' : 'WAIT'}`);
              console.log(`ğŸ“ Reason: ${mergeReason || 'Requirements not met'}`);
              
              if (canMerge) {
                console.log(`âœ… Attempting to merge PR #${pr.number}...`);
                
                try {
                  // Try squash merge first
                  await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    merge_method: 'squash',
                    commit_title: `${pr.title} (#${pr.number})`,
                    commit_message: mergeReason
                  });
                  
                  console.log(`ğŸ‰ Successfully squash merged PR #${pr.number}`);
                  
                  // Try to delete the branch
                  try {
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `heads/${pr.head.ref}`
                    });
                    console.log(`ğŸ—‘ï¸ Successfully deleted branch ${pr.head.ref}`);
                  } catch (error) {
                    console.log(`âš ï¸ Could not delete branch ${pr.head.ref}: ${error.message}`);
                  }
                  
                } catch (mergeError) {
                  console.log(`âŒ Squash merge failed: ${mergeError.message}`);
                  
                  // Try regular merge as fallback
                  try {
                    await github.rest.pulls.merge({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: pr.number,
                      merge_method: 'merge',
                      commit_message: mergeReason
                    });
                    console.log(`ğŸ‰ Successfully merge committed PR #${pr.number}`);
                  } catch (fallbackError) {
                    console.log(`âŒ All merge attempts failed: ${fallbackError.message}`);
                  }
                }
                
              } else {
                console.log(`â¸ï¸ PR #${pr.number} is not ready for auto-merge`);
                
                // Detailed blocking reasons
                if (!isMergeable) {
                  console.log('   ğŸ”´ PR is not mergeable (conflicts or other issues)');
                }
                if (!reviewApproved) {
                  console.log('   ğŸ”´ Review requirements not met');
                }
                if (!allRelevantChecksPassed) {
                  console.log('   ğŸ”´ Some relevant status checks are failing');
                }
              }
              
              console.log('================================================');
            }
            
            console.log('ğŸ Auto-merge process completed');

      - name: Cleanup on Error
        if: failure()
        run: |
          echo "âŒ Auto-merge workflow encountered an error"
          echo "ğŸ”§ This might be the self-reference issue we're trying to solve"
          echo "ğŸ’¡ Check the logs above for specific error details"
