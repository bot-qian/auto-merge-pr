name: Auto Merge Pull Requests
on:
  schedule:
    - cron: "0,30 * * * *"  # æ¯åŠå°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:
  pull_request:
    types: [opened, synchronize, ready_for_review]

jobs:
  auto_merge:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: write
      checks: read
      statuses: read
      actions: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.BOT_TOKEN || github.token }}

      - name: Set up Git
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Enhanced Auto-merge with PAT
        env:
          GH_TOKEN: ${{ secrets.BOT_TOKEN || github.token }}
          GITHUB_TOKEN: ${{ secrets.BOT_TOKEN || github.token }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_TOKEN || github.token }}
          script: |
            const currentWorkflow = context.workflow;
            console.log(`ğŸ”§ Current workflow: ${currentWorkflow}`);
            console.log(`ğŸ”‘ Using enhanced token: ${process.env.GH_TOKEN ? 'PAT' : 'GITHUB_TOKEN'}`);
            
            // è·å–æ‰€æœ‰å¼€æ”¾çš„ PR
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            
            if (prs.length === 0) {
              console.log('â„¹ï¸ No open pull requests found.');
              return;
            }
            
            console.log(`ğŸ“‹ Found ${prs.length} open PR(s)`);
            
            for (const pr of prs) {
              console.log('================================================');
              console.log(`ğŸ”„ Processing PR #${pr.number}: ${pr.title}`);
              console.log(`ğŸ‘¤ Author: ${pr.user.login}`);
              console.log(`ğŸŒ¿ Branch: ${pr.head.ref} â†’ ${pr.base.ref}`);
              console.log(`ğŸ”— URL: ${pr.html_url}`);
              
              // åˆ¤æ–­æ˜¯å¦ä¸ºè‡ªåŠ¨åŒ– PR
              const isAutomatedPR = 
                pr.user.login.includes('bot') ||
                pr.user.login === 'xuqssq' ||
                pr.title.includes('ğŸ¤–') ||
                pr.title.includes('Automated') ||
                pr.title.toLowerCase().includes('auto') ||
                pr.head.ref.includes('auto-update');
              
              console.log(`ğŸ¤– Automated PR detected: ${isAutomatedPR}`);
              
              // è·å–æ£€æŸ¥çŠ¶æ€
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              // å®šä¹‰è¦å¿½ç•¥çš„è‡ªå¼•ç”¨æ£€æŸ¥
              const selfReferenceChecks = [
                'auto_merge',
                'Auto Merge Pull Requests',
                'auto-merge-pr',
                'merge-pr'
              ];
              
              // å¯¹äºè‡ªåŠ¨åŒ– PRï¼Œä½¿ç”¨æ™ºèƒ½è¿‡æ»¤
              const relevantChecks = isAutomatedPR ? 
                checkRuns.check_runs.filter(check => 
                  !selfReferenceChecks.some(ref => 
                    check.name.toLowerCase().includes(ref.toLowerCase())
                  )
                ) : checkRuns.check_runs;
              
              const failedChecks = relevantChecks.filter(check => 
                ['failure', 'error', 'cancelled'].includes(check.conclusion)
              );
              
              console.log(`ğŸ“Š Status Summary:`);
              console.log(`   â€¢ Total checks: ${checkRuns.check_runs.length}`);
              console.log(`   â€¢ Relevant checks: ${relevantChecks.length}`);
              console.log(`   â€¢ Failed relevant checks: ${failedChecks.length}`);
              
              // è·å– PR è¯¦æƒ…
              const { data: prDetail } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              // å¢å¼ºçš„åˆå¹¶æ¡ä»¶æ£€æŸ¥
              const canMerge = 
                (prDetail.mergeable === true || prDetail.mergeable === null) &&
                !prDetail.draft &&
                prDetail.mergeable_state !== 'dirty' &&
                failedChecks.length === 0;
              
              console.log(`ğŸ¯ Merge Decision: ${canMerge ? 'MERGE' : 'WAIT'}`);
              
              if (canMerge) {
                console.log(`âœ… Attempting to merge PR #${pr.number}...`);
                
                try {
                  // é¦–å…ˆå°è¯•ä½¿ç”¨ REST API åˆå¹¶
                  const mergeResult = await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    commit_title: `${pr.title} (#${pr.number})`,
                    commit_message: `Auto-merged: ${isAutomatedPR ? 'automated update' : 'all checks passed'}`,
                    merge_method: 'squash'
                  });
                  
                  console.log(`ğŸ‰ Successfully merged PR #${pr.number}`);
                  console.log(`ğŸ“ Merge SHA: ${mergeResult.data.sha}`);
                  
                  // å°è¯•åˆ é™¤åˆ†æ”¯
                  if (pr.head.repo.full_name === pr.base.repo.full_name) {
                    try {
                      await github.rest.git.deleteRef({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        ref: `heads/${pr.head.ref}`
                      });
                      console.log(`ğŸ—‘ï¸ Successfully deleted branch: ${pr.head.ref}`);
                    } catch (deleteError) {
                      console.log(`âš ï¸ Could not delete branch: ${deleteError.message}`);
                    }
                  }
                  
                } catch (mergeError) {
                  console.log(`âŒ REST API merge failed: ${mergeError.message}`);
                  
                  // æƒé™ç›¸å…³é”™è¯¯çš„è¯¦ç»†å¤„ç†
                  if (mergeError.message.includes('Resource not accessible')) {
                    console.log('ğŸ”‘ This appears to be a permissions issue');
                    console.log('ğŸ’¡ Solutions:');
                    console.log('   1. Add a Personal Access Token (PAT) with repo permissions');
                    console.log('   2. Check if the repository has branch protection rules');
                    console.log('   3. Ensure the token has workflow permissions');
                    
                    // å°è¯•è·å–æ›´å¤šæƒé™ä¿¡æ¯
                    try {
                      const { data: permissions } = await github.rest.repos.getCollaboratorPermissionLevel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        username: context.actor
                      });
                      console.log(`ğŸ‘¤ Current user permissions: ${permissions.permission}`);
                    } catch (permError) {
                      console.log('âŒ Could not check user permissions');
                    }
                  }
                  
                  // å¦‚æœæ˜¯æƒé™é—®é¢˜ï¼Œå°è¯•ä½¿ç”¨ gh CLIï¼ˆå¦‚æœå¯ç”¨ï¼‰
                  console.log('ğŸ”„ Attempting fallback merge with gh CLI...');
                  // è¿™éƒ¨åˆ†éœ€è¦åœ¨ shell æ­¥éª¤ä¸­æ‰§è¡Œ
                }
                
              } else {
                console.log(`â¸ï¸ PR #${pr.number} is not ready for merge`);
                
                if (prDetail.mergeable === false) {
                  console.log('   ğŸ”´ Merge conflicts detected');
                }
                if (prDetail.draft) {
                  console.log('   ğŸ”´ PR is in draft mode');
                }
                if (failedChecks.length > 0) {
                  console.log('   ğŸ”´ Critical checks failing');
                }
              }
              
              console.log('================================================');
            }
            
            console.log('ğŸ Auto-merge process completed');

      - name: Fallback Merge with gh CLI
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.BOT_TOKEN || github.token }}
        run: |
          echo "ğŸ”„ Attempting fallback merge using gh CLI..."
          
          # è·å–æ‰€æœ‰å¼€æ”¾çš„ PR
          prs=$(gh pr list --state open --json number,title,mergeable --limit 100)
          
          if [[ "$prs" == "[]" ]]; then
            echo "â„¹ï¸ No open PRs found for fallback merge"
            exit 0
          fi
          
          # å°è¯•åˆå¹¶è‡ªåŠ¨åŒ– PR
          echo "$prs" | jq -c '.[] | select(.title | contains("ğŸ¤–") or contains("Automated"))' | while read -r pr; do
            pr_number=$(echo "$pr" | jq -r '.number')
            pr_title=$(echo "$pr" | jq -r '.title')
            
            echo "ğŸ”„ Attempting gh CLI merge for PR #$pr_number: $pr_title"
            
            # ä½¿ç”¨ gh pr merge å‘½ä»¤
            if gh pr merge $pr_number --squash --delete-branch --body "Auto-merged via fallback CLI method"; then
              echo "ğŸ‰ Successfully merged PR #$pr_number using gh CLI"
            else
              echo "âŒ gh CLI merge also failed for PR #$pr_number"
            fi
          done
